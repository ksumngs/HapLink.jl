<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · HapLink.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ksumngs.github.io/HapLink.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="HapLink.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="HapLink.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">HapLink.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ksumngs/HapLink.jl/blob/master/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="HapLink.Haplotype" href="#HapLink.Haplotype"><code>HapLink.Haplotype</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Haplotype(mutations::AbstractVector{Variant})</code></pre><p>Create an object to describe a group of mutations that appear together. A single <a href="#HapLink.Variant"><code>Variant</code></a> can be passed to create a haplotype of a single variant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/haplotype.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.Variant" href="#HapLink.Variant"><code>HapLink.Variant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Variant</code></pre><p>Describes a genomic mutation</p><p>The <code>Variant</code> type is based upon the <a href="https://github.com/samtools/hts-specs#variant-calling-data-files">Variant Call Format v4.2 specification</a>, albeit with imperfect compliance.</p><p><strong>Fields</strong></p><ul><li><code>chromosome::String</code>: An identifier from the reference genome or an angle-bracketed   ID String</li><li><code>position::Int</code>: The reference position</li><li><code>identifier::String</code>: Semicolon-separated list of unique identifiers where available. If   there is no identifier available, then &quot;.&quot;&quot; value should be used.</li><li><code>referencebase::NucleotideSeq</code>: Base at (or before, in case of insertion/deletion)   <code>position</code> in the reference genome</li><li><code>alternatebase::NucleotideSeq</code>: Base this mutation describes at <code>position</code>. Note that   each non-reference allele must be represented by a new <code>Variant</code>, unlike the VCF spec</li><li><code>quality::Number</code>: PHRED-scaled quality score for the assertion made by <code>alternatebase</code></li><li><code>filter::Symbol</code>: Filter status, <code>:PASS</code> is this position has passed all filters. Does Not   yet support multiple filters</li><li><code>info::Dict{String,Any}</code>: Additional information. No validation is made concerning the   keys or values.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Variant(chromosome::String, position::Int, identifier::String, referencebase::NucleotideSeq,
    alternatebase::NucleotideSeq, quality::Number, filter::Symbol, info::Dict{String,Any})

Variant(data::DataFrameRow)</code></pre><p><code>Variant</code>s can be created from the default constructor, a VCF formatted string, or via a row generated by <a href="#HapLink.transformbamcounts-Tuple{AbstractVector{String}}"><code>transformbamcounts</code></a>.</p><p>See also <a href="#HapLink.Haplotype"><code>Haplotype</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/variant.jl#L10-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.baseatreferenceposition-Tuple{XAM.BAM.Record, Int64}" href="#HapLink.baseatreferenceposition-Tuple{XAM.BAM.Record, Int64}"><code>HapLink.baseatreferenceposition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">baseatreferenceposition(record::BAM.Record, pos::Int)</code></pre><p>Get the base at reference position <code>pos</code> present in the sequence of <code>record</code>. Returns <code>nothing</code> upon an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/sequences.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.callvariants-Tuple{DataFrames.AbstractDataFrame, Int64, Int64, Float64, Float64, Float64}" href="#HapLink.callvariants-Tuple{DataFrames.AbstractDataFrame, Int64, Int64, Float64, Float64, Float64}"><code>HapLink.callvariants</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">callvariants(bamcounts::AbstractDataFrame, D_min::Int, Q_min::Int, x_min::Float64,
    f_min::Float64, α::Float64)</code></pre><p>Based on the aligned basecalls and stats in <code>bamcounts</code>, call variants.</p><p><strong>Arguments</strong></p><ul><li><code>bamcounts::AbstractDataFrame</code>: <code>DataFrame</code> containing the output from <code>bam-readcount</code></li><li><code>D_min::Int</code>: minimum variant depth</li><li><code>Q_min::Int</code>: minimum average PHRED-scaled quality at variant position</li><li><code>x_min::Float64</code>: minimum average fractional distance from read end at variant position</li><li><code>f_min::Float64</code>: minimum frequency of variant</li><li><code>α::Float64</code>: significance level of variants by Fisher&#39;s Exact Test</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Variant}</code>: <a href="#HapLink.Variant"><code>Variant</code></a>s that passed all the above filters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/variantcalling.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.containsposition-Tuple{XAM.BAM.Record, Int64}" href="#HapLink.containsposition-Tuple{XAM.BAM.Record, Int64}"><code>HapLink.containsposition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">containsposition(record::BAM.Record, i::Int)</code></pre><p>Check to see if reference posision <code>i</code> is available in <code>record</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/sequences.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.countbasestats-Tuple{String, String}" href="#HapLink.countbasestats-Tuple{String, String}"><code>HapLink.countbasestats</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">countbasestats(bamfile::String, reffile::String)</code></pre><p>Count and calculate statistics on the basecalls of the alignment in <code>bamfile</code> to the reference genome in <code>reffile</code>. Returns a <code>DataFrame</code> with stats on every base in every alignment position. See <a href="#HapLink.transformbamcounts-Tuple{AbstractVector{String}}"><code>transformbamcounts</code></a> for a complete description of the output DataFrame schema.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/readcounts.jl#L7-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.find_haplotypes-Tuple{AbstractVector{Variant}, AbstractString, Int64, Float64, Any}" href="#HapLink.find_haplotypes-Tuple{AbstractVector{Variant}, AbstractString, Int64, Float64, Any}"><code>HapLink.find_haplotypes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_haplotypes(
    variants::AbstractVector{Variant},
    bamfile::AbstractString,
    D::Int,
    α::Float64,
    haplotypemethod
)</code></pre><p>Find all combinations of <code>variants</code> that the reads in <code>bamfile</code> support as a valid haplotype with a minimum depth of <code>D</code> and Χ-squared linkage disequilibrium significance of <code>α</code>, with the haplotypes being converted into genomes via <code>haplotypemethod</code>.</p><p><strong>Arguments</strong></p><ul><li><code>variants::AbstractVector{Variant}</code>: A <code>Vector</code> of <code>Variant</code> objects which will be   combined into <code>Haplotype</code> objects and tested for validity</li><li><code>bamfile::AbstractString</code>: The path to a BAM file containing reads to check for the   presence of haplotypes</li><li><code>D::Int</code>: The minimum number of times a haplotype must be present in the reads according   to <code>haplotypemethod</code></li><li><code>α::Float64</code>: The maximum <span>$Χ$</span>-squared <span>$p$</span>-value at which to consider a haplotype   significant and worth returning.</li><li><code>haplotypemethod</code>: A function handle with the signature <code>f(h::Haplotype,   b::AbstractString)</code> which with return a table of the variant basecall matches found.   Both <a href="#HapLink.longread_genome-Tuple{Haplotype, AbstractString}"><code>longread_genome</code></a> and <a href="#HapLink.simulate_genome-Tuple{Haplotype, AbstractString}"><code>simulate_genome</code></a> fulfil this requirement.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Haplotype,Matrix{Int}}</code>: A dictionary containing every significant haplotype and its   incidence matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/haplotypecalling.jl#L8-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.linkage-Tuple{AbstractArray{Int64}}" href="#HapLink.linkage-Tuple{AbstractArray{Int64}}"><code>HapLink.linkage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linkage(counts::AbstractArray{Int})</code></pre><p>Calculates the linkage disequilibrium and Chi-squared significance level of a combination of haplotypes whose number of occurrences are given by <code>counts</code>.</p><p><code>counts</code> is an <span>$N$</span>-dimensional array where the <span>$N$</span>th dimension represents the <span>$N$</span>th variant call position within a haplotype. <code>findoccurrences</code> produces such an array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/haplotypecalling.jl#L378-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.longread_genome-Tuple{Haplotype, AbstractString}" href="#HapLink.longread_genome-Tuple{Haplotype, AbstractString}"><code>HapLink.longread_genome</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">longread_genome(haplotype::Haplotype, bamfile::AbstractString)</code></pre><p>Parse the whole-genome length reads in <code>bamfile</code> to determine each read&#39;s basecall at every variant position within <code>haplotype</code>.</p><p><strong>Arguments</strong></p><ul><li><code>haplotype::Haplotype</code>: The combination of variants to test basecalls against</li><li><code>bamfile::AbstractString</code>: The path to a BAM file containing aligned reads to be tested   for instances of <code>haplotype</code></li></ul><p><strong>Returns</strong></p><ul><li><code>MxN Array{Symbol}</code> where <code>M</code> is the number of reads present in <code>bamfile</code> and   <code>N=length(haplotype.mutations)</code>: A table of which base each read has in every variant   position of <code>haplotype</code>. The table has reads for rows and variant positions for columns,   e.g. longread_genome(...)[5,2] gives the basecall for the fifth read at the second   variant position. Basecalls are given as <code>Symbol</code> objects with possible values of<ul><li><code>:reference</code></li><li><code>:alternate</code></li><li><code>:other</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/haplotypecalling.jl#L137-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.matchvariant-Tuple{BioSequences.NucleotideSeq, Variant}" href="#HapLink.matchvariant-Tuple{BioSequences.NucleotideSeq, Variant}"><code>HapLink.matchvariant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matchvariant(base::Union{NucleotideSeq,DNA,AbstractVector{DNA}}, var::Variant)</code></pre><p>Checks if <code>base</code> matches the reference or variant expected in <code>var</code>, and returns a symbol indicating which, if any, it matches.</p><p>Returned values can be <code>:reference</code> for a reference match, <code>:alternate</code> for an alternate match, or <code>:other</code> for no match with the given variant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/sequences.jl#L73-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.mutate-Tuple{FASTX.FASTA.Record, Haplotype}" href="#HapLink.mutate-Tuple{FASTX.FASTA.Record, Haplotype}"><code>HapLink.mutate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function mutate(seq::FASTA.Record, haplotype::Haplotype)
function mutate(seq::NucleotideSeq, haplotype::Haplotype)</code></pre><p>Give the reference sequence <code>seq</code> mutations to match the position and basecalls of <code>haplotype</code>. Returns a new sequence, leaving <code>seq</code> unmodified.</p><p>When mutating a <code>FASTA.Record</code>, the new record is given a new unique identifier and description based on the SHA1 hash of the complete genotype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/sequences.jl#L122-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.myref2seq-Tuple{BioAlignments.Alignment, Int64}" href="#HapLink.myref2seq-Tuple{BioAlignments.Alignment, Int64}"><code>HapLink.myref2seq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">myref2seq(aln::Alignment, i::Int)</code></pre><p>Replicates the functionality of BioAlignments <code>ref2seq</code>, but can handle hard clips by effectively removing them for the intent of finding the position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/sequences.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.occurrence_matrix-Tuple{AbstractArray{Symbol}}" href="#HapLink.occurrence_matrix-Tuple{AbstractArray{Symbol}}"><code>HapLink.occurrence_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">occurrence_matrix(readmatches::AbstractArray{Symbol})</code></pre><p>Transforms the haplotype occurrence table <code>readmatches</code> into an incidence matrix</p><p><strong>Arguments</strong></p><ul><li><code>readmatches::AbstractArray{Symbol}</code>: An <span>$m$</span>x<span>$n$</span> array where <span>$m$</span> is the number of   reads represented, and <span>$n$</span> is the number of variants in the haplotype considered, e.g.   readmatches[4,3] represents the match value for the third variant in the fourth read.   Valid values in the array are <code>:reference</code>, <code>:alternate</code>, and <code>:other</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>2x2x... Array{Int64, size(readmatches)[2]}</code>: An <span>$N$</span>-dimensional matrix where <span>$N$</span> is   the number of variant positions in <code>readmatches</code>. The <span>$1$</span> index position in the   <span>$n$</span>th dimension represents the number of times the <span>$n$</span>th variant position was found   to have the reference base called, while the <span>$2$</span> index position represents the number   of times the <span>$n$</span>th variant position was found to have the alternate base called. E.g.   <code>first(occurrence_matrix(reads))</code> gives the number of times the all-reference base   haplotype was found in <code>reads</code>, while <code>occurrence_matrix(reads)[end]</code> gives the number   of times the all-alternate base haplotype was found.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pseudoreads = [
           :reference :reference :reference
           :reference :reference :alternate
           :reference :reference :alternate
           :reference :reference :other
       ];

julia&gt; occurrence_matrix(pseudoreads)
2×2×2 Array{Int64, 3}:
[:, :, 1] =
 1  0
 0  0

[:, :, 2] =
 2  0
 0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/haplotypecalling.jl#L321-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.overlap_inrange-Tuple{XAM.BAM.Record, XAM.BAM.Record}" href="#HapLink.overlap_inrange-Tuple{XAM.BAM.Record, XAM.BAM.Record}"><code>HapLink.overlap_inrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlap_inrange(record1::BAM.Record, record2::BAM.Record; min::Int=0, max::Int=100)</code></pre><p>Check if <code>record1</code> and <code>record2</code> overlap by an amount between <code>min</code> and <code>max</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/sequences.jl#L176-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.phrederror-Tuple{Number}" href="#HapLink.phrederror-Tuple{Number}"><code>HapLink.phrederror</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phrederror(quality::Number)</code></pre><p>Converts a PHRED33-scaled error number into the expected fractional error of basecall</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/variantcalling.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.savevcf-Tuple{AbstractVector{Variant}, AbstractString, AbstractString, Int64, Number, Float64, Float64}" href="#HapLink.savevcf-Tuple{AbstractVector{Variant}, AbstractString, AbstractString, Int64, Number, Float64, Float64}"><code>HapLink.savevcf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">savevcf(vars::AbstractVector{Variant}, savepath::String, refpath::String, D::Int,
    Q::Number, x::Float64, α::Float64)</code></pre><p>Save a VCF file populated with <code>vars</code></p><p><strong>Arguments</strong></p><ul><li><code>vars::AbstractVector{Variant}</code>: <code>Vector</code> of <a href="#HapLink.Variant"><code>Variant</code></a>s to write to file</li><li><code>savepath::AbstractString</code>: path of the VCF file to write to. Will be overwritten</li><li><code>refpath::AbstractString</code>: path of the reference genome used to call variants. The   absolute path will be added to the <code>##reference</code> metadata</li><li><code>D::Int</code>: mimimum variant depth used to filter variants. Will be added as <code>##FILTER</code>   metadata</li><li><code>Q::Number</code>: minimum PHRED quality used to filter variants. Will be added as <code>##FILTER</code>   metadata</li><li><code>x::Float64</code>: minimum fractional read position used to filter variants. Will be added as   <code>##FILTER</code> metadata</li><li><code>α::Float64</code>: Fisher&#39;s Exact Test significance level used to filter variants. Will be   added as <code>##FILTER</code> metadata</li></ul><p>Saves the variants in <code>vars</code> to a VCF file at <code>savepath</code>, adding the reference genome <code>refpath</code>, the depth cutoff <code>D</code>, the quality cutoff <code>Q</code>, the position cutoff <code>x</code>, and the significance cutoff <code>α</code> as metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/variantcalling.jl#L71-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.serialize_vcf-Tuple{Variant}" href="#HapLink.serialize_vcf-Tuple{Variant}"><code>HapLink.serialize_vcf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">serialize_vcf(v::Variant)</code></pre><p>Create a VCF line to represent <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/variant.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.serialize_yaml-Tuple{Variant}" href="#HapLink.serialize_yaml-Tuple{Variant}"><code>HapLink.serialize_yaml</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">serialize_yaml(v::Variant)</code></pre><p>Create a valid YAML representation of <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/variant.jl#L170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.simulate_genome-Tuple{Haplotype, AbstractString}" href="#HapLink.simulate_genome-Tuple{Haplotype, AbstractString}"><code>HapLink.simulate_genome</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_genome(haplotype::Haplotype, bamfile::AbstractString; iterations::Int64=1000)</code></pre><p>Simulate a set of <code>iterations</code> reads that contain all of the variant positions in <code>haplotype</code> containing the actual reads present in <code>bamfile</code> via a maximum likelihood method.</p><p><code>simulate_genome</code> examines each variant position in <code>haplotype</code> and finds a random read containing that position from <code>bamfile</code>. It will then check if the next variant position is contained on the previous read, and if not pick a new random read that contains that variant position. In this way, it assembles a set of reads that conceivably could have come from the same template strand via maximum likelihood.</p><p><strong>Arguments</strong></p><ul><li><code>haplotype::Haplotype</code>: The combination of variants to test the aligned reads for evidence   of</li><li><code>bamfile::AbstractString</code>: The path to a BAM file containing aligned reads to be tested   for instances of <code>haplotype</code></li></ul><p><strong>Keywords</strong></p><ul><li><code>iterations::Integer=1000</code>: The number of times to combine reads and test for the presence   of <code>haplotype</code></li><li><code>nextreadcandidates</code>: A function handle of the signature <code>f(r1::BAM.Record,   r2::BAM.Record, pos::AbstractVecOrMat{Int})</code> that determines if <code>r2</code> can be paired in   the same simulated genome as <code>r2</code> based on the variant positions listed in <code>pos</code></li></ul><p><strong>Returns</strong></p><ul><li><code>MxN Array{Symbol}</code> where <code>M=iterations</code> and <code>N=length(haplotype.mutations)</code>: A table of   which base each simulated read has in every variant position of <code>haplotype</code>. The table   has reads for rows and variant positions for columns, e.g. simulate_genome(...)[5,2]   gives the basecall for the fifth simulated read at the second variant position.   Basecalls are given as <code>Symbol</code> objects with possible values of<ul><li><code>:reference</code></li><li><code>:alternate</code></li><li><code>:other</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/haplotypecalling.jl#L211-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.sumsliced" href="#HapLink.sumsliced"><code>HapLink.sumsliced</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sumsliced(A::AbstractArray, dim::Int, pos::Int=1)</code></pre><p>Sum all elements that are that can be referenced by <code>pos</code> in the <code>dim</code> dimension of <code>A</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(1:8, 2, 2, 2)
2×2×2 reshape(::UnitRange{Int64}, 2, 2, 2) with eltype Int64:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 5  7
 6  8

julia&gt; sumsliced(A, 2)
14

julia&gt; sumsliced(A, 2, 2)
22</code></pre><p>Heavily inspired by Holy, Tim &quot;Multidimensional algorithms and iteration&quot; <a href="https://julialang.org/blog/2016/02/iteration/#filtering_along_a_specified_dimension_exploiting_multiple_indexes">https://julialang.org/blog/2016/02/iteration/#filtering_along_a_specified_dimension_exploiting_multiple_indexes</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/haplotypecalling.jl#L407-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.transformbamcounts-Tuple{AbstractVector{String}}" href="#HapLink.transformbamcounts-Tuple{AbstractVector{String}}"><code>HapLink.transformbamcounts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transformbamcounts(bamcounts::AbstractVector{String})</code></pre><p>Convert the output from <a href="https://github.com/genome/bam-readcount">bam-readcount</a> to a <code>DataFrame</code>.</p><p><strong>Schema</strong></p><table><tr><th style="text-align: right">Column name</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right"><code>chr</code></td><td style="text-align: left">Chromosome</td></tr><tr><td style="text-align: right"><code>position</code></td><td style="text-align: left">Position</td></tr><tr><td style="text-align: right"><code>reference_base</code></td><td style="text-align: left">Reference base</td></tr><tr><td style="text-align: right"><code>depth</code></td><td style="text-align: left">Total read depth at <code>position</code></td></tr><tr><td style="text-align: right"><code>base</code></td><td style="text-align: left">Alternate base</td></tr><tr><td style="text-align: right"><code>count</code></td><td style="text-align: left">Number of reads containing <code>base</code> at <code>position</code></td></tr><tr><td style="text-align: right"><code>avg_mapping_quality</code></td><td style="text-align: left">Mean mapping quality</td></tr><tr><td style="text-align: right"><code>avg_basequality</code></td><td style="text-align: left">Mean base quality at <code>position</code></td></tr><tr><td style="text-align: right"><code>avg_se_mapping_quality</code></td><td style="text-align: left">Mean single-ended mapping quality</td></tr><tr><td style="text-align: right"><code>num_plus_strand</code></td><td style="text-align: left">Number of reads on the forward strand (N/A)</td></tr><tr><td style="text-align: right"><code>num_minus_strand</code></td><td style="text-align: left">Number of reads on the reverse strand (N/A)</td></tr><tr><td style="text-align: right"><code>avg_pos_as_fraction</code></td><td style="text-align: left">Average position on the read as a fraction, 0 (end) to 1 (center)</td></tr><tr><td style="text-align: right"><code>avg_num_mismatches_as_fraction</code></td><td style="text-align: left">Average number of mismatches on these reads per base</td></tr><tr><td style="text-align: right"><code>avg_sum_mismatch_qualities</code></td><td style="text-align: left">Average sum of the base qualities of mismatches in the reads</td></tr><tr><td style="text-align: right"><code>num_q2_containing_reads</code></td><td style="text-align: left">Number of reads with q2 runs at the 3&#39; end</td></tr><tr><td style="text-align: right"><code>avg_distance_to_q2_start_in_q2_reads</code></td><td style="text-align: left">Average distance of position (as fraction of unclipped read length) to the start of the q2 run</td></tr><tr><td style="text-align: right"><code>avg_clipped_length</code></td><td style="text-align: left">Average clipped read length</td></tr><tr><td style="text-align: right"><code>avg_distance_to_effective_3p_end</code></td><td style="text-align: left">Average distance to the 3&#39; end of the read (as fraction of unclipped read length)</td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/readcounts.jl#L31-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HapLink.variant_positions_match-Tuple{XAM.BAM.Record, XAM.BAM.Record, AbstractVecOrMat{Int64}}" href="#HapLink.variant_positions_match-Tuple{XAM.BAM.Record, XAM.BAM.Record, AbstractVecOrMat{Int64}}"><code>HapLink.variant_positions_match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variant_positions_match(
    record1::BAM.Record,
    record2::BAM.Record,
    variantpositions::AbstractVecOrMat{Int}
)</code></pre><p>Check <code>record1</code> and <code>record2</code> at and return <code>true</code> if the basecalls are identical at every position in <code>variantpositions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ksumngs/HapLink.jl/blob/8ac0986dbb125354dcbb36cacf1d96c277585595/src/sequences.jl#L151-L160">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Monday 24 January 2022 20:13">Monday 24 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
